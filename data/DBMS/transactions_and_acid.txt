TRANSACTIONS & ACID PROPERTIES

A transaction is a sequence of one or more operations (read/write) performed as a single logical unit of work.
Transactions ensure data consistency even with failures or concurrency.

What Is a Transaction?

A transaction transforms the database from one consistent state to another.

Example (Bank Transfer):

T1:
read(A)
A = A – 500
write(A)
read(B)
B = B + 500
write(B)

Either the entire transfer completes or nothing happens.

ACID Properties

ACID stands for Atomicity, Consistency, Isolation, Durability.

2.1 Atomicity
All or nothing.
If a failure occurs, all partial updates are undone.
Implemented using undo logging.

2.2 Consistency
A transaction must maintain valid data according to constraints and rules.
Example: total balance remains constant.

2.3 Isolation
Concurrent transactions must not interfere with each other.
Prevents anomalies: dirty reads, lost updates, non-repeatable reads, phantom reads.
Implemented using locks, timestamps, MVCC.

2.4 Durability
Committed changes must persist even after a crash.
Implemented using redo logs and WAL (Write-Ahead Logging).

Transaction States

Active → Partially Committed → Committed → Terminated
↘
Aborted → Terminated

Active: executing
Partially committed: last operation done
Committed: changes are permanent
Failed: cannot proceed
Aborted: rolled back

Types of Transaction Failures

Logical errors
System crash
Disk failure

Schedules in Transactions

A schedule defines the order of operations from multiple transactions.

5.1 Serial Schedule
Transactions run one by one.
Correct but low concurrency.

5.2 Concurrent Schedule
Operations interleave for higher throughput.

Serializability

A schedule is serializable if its effect is equivalent to a serial schedule.

6.1 Conflict Serializability
Check with precedence graph:
If no cycle → conflict-serializable.

6.2 View Serializability
More general but harder to test.
Conflict serializability is commonly used.

Concurrency Issues

Without isolation:

Dirty read
Unrepeatable read
Lost update
Phantom read

Handled by concurrency control methods.

Transaction Isolation Levels (SQL Standard)

Read Uncommitted → allows dirty reads
Read Committed → prevents dirty reads
Repeatable Read → prevents dirty + unrepeatable reads
Serializable → prevents all anomalies; highest cost

Implementing ACID

Atomicity → Undo logging
Durability → Redo logging
Isolation → Concurrency control
Consistency → Constraints and rules

Examples

10.1 Bank Transfer
BEGIN;
UPDATE Accounts SET Bal = Bal - 500 WHERE AccNo = 1;
UPDATE Accounts SET Bal = Bal + 500 WHERE AccNo = 2;
COMMIT;

10.2 Order Processing
BEGIN;
INSERT INTO Orders VALUES (...);
UPDATE Inventory SET Qty = Qty - 1 WHERE ItemID = 10;
COMMIT;

Summary

Transactions ensure reliable database operations:

Atomicity: roll back incomplete work
Consistency: preserve valid states
Isolation: correct concurrent execution
Durability: changes persist